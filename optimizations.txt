Expression optimizations to code into this compiler.

Expressions are represented in memory as a tree, with the node as the operator
and the child nodes the expressions, identifiers, or constants to operate on.
The expression tree is evaluated by recursion down the child nodes, then the
result is carried back up the tree. Therefore, operations at the leaves are
carried out first.

  ((a + b) - c) + d

  would be

     _
    |\
      \
  +    \
    -   \
      +  \
        a \______ Evaluation order
        b
      c
    d


  +             <---- (a + b)
    a
    b

  +             <---- ((result of - operator) + d)
    -           <---- ((result of + operator) - c)
      +         <---- (a + b)
        a
        b
      c
    d

The goal of the optimization is to simplify and rework the expression without
changing the result of the expression. However, some side effects of the
simplification are ignored:

  - Exact results of integer overflow. Optimizations will not affect the result
    unless the result relies on intricate knowledge of integer overflow.

    Consider:

    a * b + a * c == a * (b + c)

    Optimization should not affect the result of this expression unless the
    programmer relies on a * b and a * c overflowing the integer datatype
    in a specific manner, where then a * b + a * c would overflow differently
    from a * (b + c).

===============================================================================
* Multiply/divide where one operand is negated

* How it would be implemented:

  Match: (-a * a) or (-a / a)

  *                         <- node
    NEGATE                  <- op = node->child[0], negate_i = 0
      a                     <- a1 = op->child[0] = node->child[0]->child[0]
    a                       <- a2 = node->child[1]

  Convert to: -(a * a) or -(a / a)

  NEGATE                    <- node
    *                       <- op = node->child[0]
      a                     <- a1 = op->child[0] = node->child[0]->child[0]
      a                     <- a2 = op->child[1] = node->child[0]->child[1]

  Match: (a * -a) or (a / -a)

  *                         <- node
    a                       <- a2 = node->child[0]
    NEGATE                  <- op = node->child[1], negate_i = 1
      a                     <- a1 = op->child[0] = node->child[1]->child[0]

  Convert to: -(a * a) or -(a / a)

  NEGATE                    <- node
    *                       <- op = node->child[0]
      a                     <- a1 = op->child[0] = node->child[0]->child[0]
      a                     <- a2 = op->child[1] = node->child[0]->child[1]

  Results:

  The NEGATE operator is moved up out of the multiply/divide.

  How:

  - Determine which child node in node 'node' has the NEGATE token.
    Store the index of that child node in 'negate_i', update pointer 'op'
    to point to it:

      op = node->child[negate_i];

  - Change node->token from '*' to NEGATE

  - Change op->token from NEGATE to '*'

  - Remove and clear node 'a2' from child node 'negate_i' of 'node'.
    Keep a reference to 'a2'.

  - If negate_i == 1 (op comes from second child node of 'node'),
    Then remove and clear node 'op' from second child node of 'node',
    attach and reference to first child node of 'node', set negate_i = 0, then:

      op = node->child[negate_i];

  - Attach node 'a2' to second child node slot of node 'op'.

===============================================================================
* Distributive property in reverse

* How it would be implemented:

  Match: (a * b) + (a * c) or
         (a * b) - (a * c)

  +                             <- node
    *                           <- op1 = node->child[0]
      a                         <- a1 = op1->child[0] = node->child[0]->child[0]
      b                         <- b = op1->child[1] = node->child[0]->child[1]
    *                           <- op2 = node->child[1]
      a                         <- a2 = op2->child[0] = node->child[1]->child[0]
      c                         <- c = op2->child[1] = node->child[1]->child[1]

  Convert to: a * (b + c) or
              a * (b - c)

  *                             <- node
    a                           <- a = node->child[0]
    +                           <- op = node->child[1]
      b                         <- b = op->child[0] = node->child[1]->child[0]
      c                         <- c = op->child[1] = node->child[1]->child[1]

  Results:

  The node token is changed to '*'. The first node child is changed to 'a'.
  op2 token is changed to '+'. 'b' is moved from the first node child to
  the second node child.

  How:

  - Change node->token to '*'.

  - Change op2->token to '+'.

  - Remove and clear node 'a2' (first child) from node 'op2'. Unreference and delete 'a2'.

  - Remove and clear node 'b' (second child) from node 'op1'. Attach 'b' to first child
    node slot of 'op2'.

  Result:

  *                             <- node
    *                           <- op1 = node->child[0]
      a                         <- a1 = op1->child[0] = node->child[0]->child[0]
      (null)                    <- b = op1->child[1] = node->child[0]->child[1]
    +                           <- op2 = node->child[1]
      b                         <- a2 = op2->child[0] = node->child[1]->child[0]
      c                         <- c = op2->child[1] = node->child[1]->child[1]

  - Remove and clear node 'a1' (first child) from node 'op1'. Keep a reference to 'a1'.

  - Remove and clear node 'op1' (first child) from node 'node'. Unreference and delete 'op1'.

  - Attach 'a1' to first child node of 'node'.

===============================================================================
* Subtract a from a

* How it would be implemented:

  Match: (a - a)

  -                         <- node
    a                       <- a1 = node->child[0]
    a                       <- a2 = node->child[1]

  Convert to: 0

  0

  Results:

  Both child nodes are released, cleared, and deleted. 'node' is set to integer
  constant '0'.

  How:

  - Change 'node' token from / to I_CONSTANT. Set node integer constant to 0.

  - Release and clear child nodes 'a1' and 'a2'. Unreference and delete them.

===============================================================================
* Multiply/divide where both operands are negated

* How it would be implemented:

  Match: (-a * -a) or (-a / -a)

  *                         <- node
    NEGATE                  <- neg1 = node->child[0]
      a                     <- a1 = neg1->child[0] = node->child[0]->child[0]
    NEGATE                  <- neg2 = node->child[1]
      a                     <- a2 = neg2->child[0] = node->child[1]->child[0]

  Convert to: (a * a) or (a / a)

  *                         <- node
    a                       <- a1 = node->child[0]
    a                       <- a2 = node->child[1]

  Results:

  NEGATE nodes are removed. The 'a' nodes are moved up to take their places.

  How:

  - Release and clear child nodes 'neg1' and 'neg2' from 'node'.
    Keep the references.

  - Release and clear child node 'a1' from 'neg1' and 'a2' from 'neg2'.
    Attach 'a1' to first child node slot of 'node'. Attach 'a2' to second
    child node slot of 'node'.

  - Unreference and delete nodes 'neg1' and 'neg2'.

===============================================================================
* Divide a by a

* How it would be implemented:

  Match: (a / a)

  /                         <- node
    a                       <- a1 = node->child[0]
    a                       <- a2 = node->child[1]

  Convert to: 1

  1

  Results:

  Both child nodes are released, cleared, and deleted. 'node' is set to integer
  constant '1'.

  How:

  - Change 'node' token from / to I_CONSTANT. Set node integer constant to 1.

  - Release and clear child nodes 'a1' and 'a2'. Unreference and delete them.

===============================================================================
* Subtract from 0

* How it would be implemented:

  Match: (0 - a)

  -                         <- node
    0                       <- zero = node->child[0]
    a                       <- a = node->child[1]

  Convert to: -a

  NEGATE                    <- node
    a                       <- a = node->child[0]

  Results:

  Subtraction is converted to simple negation.

  How:

  - Change node->token to NEGATE.

  - Remove and clear child node 'zero' from node 'node'. Unreference and delete 'neg'.

  - Detach 'a' from second child node slot of 'node' and attach to first child node
    slot of 'node'.

===============================================================================
* Add/subtract by NEGATE

* How it would be implemented:

  Match: (a + -b) or (a - -b)

  +                         <- node
    a                       <- a = node->child[0]
    NEGATE                  <- neg = node->child[1]
      b                     <- b = neg->child[0] = node->child[1]->child[0]

  Convert to: (a - b) or (a + b)

  -                         <- node
    a                       <- a = node->child[0]
    b                       <- b = node->child[1]

  Results:

  Addition is converted to subtraction, or subtraction converted to addition,
  and NEGATE node is removed. 'b' node is moved up into second child node
  slot of 'node'.

  How:

  - Change node->token from '-' to '+', or '+' or '-'

  - Remove and clear child node 'b' from node 'neg'. Keep a reference to 'b'.

  - Remove and clear child node 'neg' from node 'node'. Unreference and delete 'neg'.

  - Attach node 'b' to second child slot of 'node'.

===============================================================================
* Multiply by -1: a * -1 = -a

* How it would be implemented:

  Match: (a * -1) or (a * -1.0)

  *                         <- node
    a                       <- a = node->child[0]
    -1                      <- neg1 = node->child[1]

  Convert to: -a

  NEGATE                    <- node
    a                       <- a = node->child[0]

  Results:

  Token is changed from * to NEGATE. 'neg1' is released and cleared, deleted.
  'a' is not touched.

  How:

  - Change 'node' token from * to NEGATE.

  - Release and clear child node 'neg1' from 'none', unreference and delete 'neg1'.

===============================================================================
* Multiply by zero elimination: a * 0 = 0

  If the optimizer sees that something is multiplied by zero, it should replace
  the node and it's children with integer constant zero. All nodes in the tree
  below that point should be dereferenced and deleted. The expression multiplied
  by zero should be completely removed because multiplication by zero makes the
  result irrelevent.

* How it would be implemented:

  Match: a * 0

  *                         <- node
    a                       <- a = node->child[0]
    0                       <- zero = node->child[1]

  Convert to: 0

  0                         <- node

  Results:

  Node is replaced by integer constant 0. 'a' and 'zero'
  are unreferenced and deleted. Child nodes of 'a' are
  unreferenced and deleted, all the way down the tree.

  How:

  - Release and clear child node 'a' from 'node', keep now-disconnected 'a' node.

  - Release and clear child node 'zero' from 'node'. Unreference and delete 'zero'.

  - Prune 'a' and all child nodes beneath 'a'. Unreference and delete 'a'.

===============================================================================
* Add/subtract by zero elimination:

  a + 0 = a
  a - 0 = a

* How it would be implemented:

  Match: (a + 0) or (a - 0)

  +                         <- node
    a                       <- a = node->child[0]
    0                       <- zero = node->child[1]

  Convert to: a

  a                         <- node

  Results:

  + or - operator is replaced with 'a' node, child nodes included.

  How:

  - Release and clear child node 'zero' from 'node', unreference and delete 'zero'.

  - Release and clear child node 'a' from 'node'. Keep a reference to 'a'.

  - All child nodes in 'node' should be NULL at this point. The - and + operators
    should have no more than two child nodes.

  - Copy token and value union from 'a' to 'node'.

  - For each child node in 'a', detach from 'a' and attach to 'node' (maintain
    child node index).

  - All child nodes in 'a' should be NULL at this point.

  - Unreference and delete 'a'.

===============================================================================
* Addition/subtraction reordering: Move addition to the right (down to the
  leaves), subtraction to the left (up from the leaves).

  Subtraction is not commutative. (a - b) != (b - a). But, subtraction from
  the first result on can be treated as commutative. You can reorder the
  operands in a string of subtractions so long as you do not reorder the
  first operand of the first subtraction.

  a - b - c - d == a - c - b - d == a - d - c - b

  a - b - c - d != b - a - c - d

  Addition and subtraction have the same precedence in order of operations,
  therefore among a string of addition and subtraction you work left to right.
  Grouping addition and subtraction is meant to enable further optimization,
  including grouping by identifiers to convert multiple additions into a
  multiply by constant.

  a + b - c - d + e - f + g + h - i - j

  would become (as an example)

  a + b + e + g + h - i - j - c - d - f

* How it would be implemented:

  Match: a - b + c

  +                         <- node
    -                       <- op = node->child[0]
      a                     <- a = op->child[0] = node->child[0]->child[0]
      b                     <- b = op->child[1] = node->child[0]->child[1]
    c                       <- c = node->child[1]

  Convert to: a + c - b

  -                         <- node
    +                       <- op = node->child[0]
      a                     <- a = op->child[0] = node->child[0]->child[0]
      c                     <- c = op->child[1] = node->child[0]->child[1]
    b                       <- b = node->child[1]

  Results:

  'b' and 'c' switch places.
  'a' is unchanged.
  'node' and 'op' switch tokens (operators).

  How:

  - Swap node->token and op->token. Should result node->token == '-' and op->token == '+'.

  - Swap 'b' and 'c':

      - Release and zero op->child[1], keep now-disconnected node 'b'

      - Release and zero node->child[1], keep now-disconnected node 'c'

      - Attach and addref node 'b' to node->child[1]

      - Attach and addref node 'c' to op->child[1]

===============================================================================
* Multiply/divide reordering: Move multiplication to the right (down to the
  leaves), divison to the left (up from the leaves).

  This would work in the same way as the add/subtract reordering.

  Note that this optimization CANNOT work unless all operands are floating
  point! Integer division uses truncation in a way that alters the result
  when reordered with multiplication.

  Consider:

        a = 5
        b = 2
        c = 4

  a / b * c                 a * c / b

  Floating point result:
  ---------------------------------------------------------
  a / b = 5 / 2 = 2.5       a * c = 5 * 4 = 20
  2.5 * c = 2.5 * 4 = 10    20 / b = 20 / 2 = 10

  Integer result:
  ---------------------------------------------------------
  a / b = 5 / 2 = 2         a * c = 5 * 4 = 20
  2 * c = 2 * 4 = 8         20 / b = 20 / 2 = 10

* How it would be implemented:

  Match: a / b * c

  *                         <- node
    /                       <- op = node->child[0]
      a                     <- a = op->child[0] = node->child[0]->child[0]
      b                     <- b = op->child[1] = node->child[0]->child[1]
    c                       <- c = node->child[1]

  Convert to: a * c / b

  /                         <- node
    *                       <- op = node->child[0]
      a                     <- a = op->child[0] = node->child[0]->child[0]
      c                     <- c = op->child[1] = node->child[0]->child[1]
    b                       <- b = node->child[1]

  Results:

  'b' and 'c' switch places.
  'a' is unchanged.
  'node' and 'op' switch tokens (operators).

  How:

  - Swap node->token and op->token. Should result node->token == '/' and op->token == '*'.

  - Swap 'b' and 'c':

      - Release and zero op->child[1], keep now-disconnected node 'b'

      - Release and zero node->child[1], keep now-disconnected node 'c'

      - Attach and addref node 'b' to node->child[1]

      - Attach and addref node 'c' to op->child[1]

===============================================================================
* Add/multiply drawing out subexpressions.

* How it would be implemented:

  Match: (x...) + (a + b), or
         (x...) * (a * b)

  +                         <- node
    (x...)                  <- x = node->child[0]
    +                       <- op = node->child[1]
      a                     <- a = op->child[0] = node->child[1]->child[0]
      b                     <- b = op->child[1] = node->child[1]->child[1]

  Convert to: ((x...) + a) + b or
              ((x...) * a) * b

  +                         <- node
    +                       <- op = node->child[0]
      (x...)                <- x = op->child[0] = node->child[0]->child[0]
      a                     <- a = op->child[1] = node->child[0]->child[1]
    b                       <- b = node->child[1]

  Ideal match: (c + d) + (a + b)

  +                         <- node
    +                       <- (c + d) expression aka 'x'
      c
      d
    +                       <- op
      a
      b

  Convert to: ((c + d) + a) + b

  +                         <- node
    +                       <- op
      +                     <- (c + d) expression aka 'x'
        c
        d
      a                     <- a
    b                       <- b

  Results:

  'x' node is moved in with 'a' to add them first, 'b' is moved to second
  child node of 'node', to represent (x...) + a + b instead of (x...) + (a + b).

  How:

  - In node 'op', have 'a' and 'b' swap child node slots with each other.
    a = op->child[1] and b = op->child[0].

  - In node 'node', have 'x' and 'op' swap child node slots with each other.
    x = node->child[1] and op = node->child[0]

  At this point:

  +                         <- node
    +                       <- op = node->child[0]
      b                     <- b = op->child[0] = node->child[0]->child[0]
      a                     <- a = op->child[1] = node->child[0]->child[1]
    (x...)                  <- x = node->child[1]

  - Release and clear node 'x' from 'node' second child node slot, keep the reference.
    node->child[1] = NULL.

  - Release and clear node 'b' from 'op' first child node slot, keep the reference.
    op->child[0] = NULL.

  - Attach node 'x' to first child node slot of 'op'.
    op->child[0] = x.

  - Attach node 'b' to second child node slot of 'node'.
    node->child[1] = b.

